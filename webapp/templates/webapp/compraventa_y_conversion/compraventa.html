{% extends "webapp/base.html" %}
{% load static %}
{% load permissions_tags %}
{% block extra_css %}
<link rel="stylesheet" href="{% static 'webapp/css/paginas_principales/home.css' %}">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<link rel="stylesheet" href="{% static 'webapp/css/compraventa/compraventa.css' %}">
{% endblock %}

{% block title %}Compra y Venta de Divisas{% endblock %}

{% block content %}
<div class="container py-4">
    <h2 class="converter-title">
        <span class="yellow-text">Compra</span> <span class="black-text">venta</span>
    </h2>

    <!-- üÜï Indicador superior de pasos - OCULTO -->
    <div class="wizard-header d-none">
        <div id="indicator-step1" class="wizard-step-indicator active">
            <span>1</span> Selecci√≥n
        </div>
        <div id="indicator-step2" class="wizard-step-indicator">
            <span>2</span> Revisi√≥n
        </div>
    </div>

    <form method="post">
        {% csrf_token %}

        <!-- üÜï PASO 1: Selecci√≥n -->
        <div id="step-1" class="wizard-step active">
            <div class="converter-section mb-4">
                <!-- Layout de 3 columnas horizontales -->
                <div class="converter-section">
                    <div class="converter-container converter-horizontal-layout">
                        
                        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                             COLUMNA 1: Selecci√≥n de Divisas
                             ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                        <div class="converter-column column-divisa">
                            <p class="converter-subtitle">¬øC√≥mo quiere su divisa?</p>
                            
                            <div class="converter-form">
                                <!-- From Currency -->
                                <div class="converter-field">
                                    <label class="field-label">Tengo esta moneda</label>
                                    <div class="field-row">
                                        <!-- Custom Dropdown para moneda origen -->
                                        <div class="currency-dropdown" id="dropdown-from">
                                            <div class="currency-dropdown-button" id="btn-from">
                                                <img id="simu-from-flag" src="" alt="bandera" class="currency-flag">
                                                <span id="simu-from-code" class="currency-code">USD</span>
                                                <svg class="select-arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                                    <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" />
                                                </svg>
                                            </div>
                                            <div class="currency-dropdown-menu" id="menu-from">
                                                <!-- Opciones se llenan con JS -->
                                            </div>
                                            <!-- Select oculto para mantener compatibilidad con el form -->
                                            <select id="simu-from" name="moneda_origen" style="display:none;"></select>
                                        </div>
                                        <input
                                            id="simu-amount"
                                            name="monto_origen"
                                            type="text"
                                            class="amount-input"
                                            placeholder="0 USD"
                                        >
                                    </div>
                                    <div id="tauser-suggestion-amount" 
                                        style="display:none; color:#1b73e8; font-size:14px; margin-top:4px;">
                                    </div>
                                </div>

                                <!-- To Currency -->
                                <div class="converter-field">
                                    <label class="field-label">Quiero esta moneda</label>
                                    <div class="field-row">
                                        <!-- Custom Dropdown para moneda destino -->
                                        <div class="currency-dropdown" id="dropdown-to">
                                            <div class="currency-dropdown-button" id="btn-to">
                                                <img id="simu-to-flag" src="" alt="bandera" class="currency-flag">
                                                <span id="simu-to-code" class="currency-code">PYG</span>
                                                <svg class="select-arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                                    <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" />
                                                </svg>
                                            </div>
                                            <div class="currency-dropdown-menu" id="menu-to">
                                                <!-- Opciones se llenan con JS -->
                                            </div>
                                            <!-- Select oculto para mantener compatibilidad con el form -->
                                            <select id="simu-to" name="moneda_destino" style="display:none;"></select>
                                        </div>
                                        <input name="monto_destino" type="text" readonly class="result-input" id="simu-result-main" placeholder="0 PYG">
                                    </div>
                                    <!-- ‚ö†Ô∏è Aqu√≠ aparece el mensaje inline si NO coincide con billetes reales -->
                                    <div id="tauser-suggestion-out" 
                                        style="display:none; color:#1b73e8; font-size:14px; margin-top:4px;">
                                    </div>
                                </div>

                                <div class="converter-actions">
                                    <button id="simu-intercambiar" type="button" class="intercambiar-button">INTERCAMBIAR</button>
                                </div>
                                
                                <div class="converter-result">
                                    <p id="simu-result-detail" class="result-detail">Ingres√° un monto para calcular</p>
                                    <p class="result-detail">Cotizaci√≥n exclusiva para la categoria: {{categoria_cliente.nombre}}</p>
                                </div>
                            </div>
                        </div>

                        {% is_usuario_asociado request.user as usuario_asociado %}
                        {% if usuario_asociado %}
                        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                             COLUMNA 2: Medio de Pago
                             ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                        <div class="converter-column column-pago">
                            <p class="converter-subtitle">¬øC√≥mo quiere pagar?</p>
                            
                            <div class="converter-field-content metodo-content" id="pago-content">
                                <div class="tab-row metodo-tabs" id="pago-tabs">
                                {% for tipo in tipos_pago %}
                                    <button type="button" class="tab-btn metodo-btn {% if forloop.first %}active{% endif %}" data-tipo-general="{{ tipo.id }}" data-tipo-nombre="{{ tipo.nombre }}">
                                        {% if tipo.nombre == "Tauser" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/1.Tauser.png' %}" alt="Tauser" class="metodo-icon tauser-icon">
                                            <span class="metodo-text">Tauser (TAS)</span>
                                        {% elif tipo.nombre == "Tarjeta Nacional" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/2.Tarjeta.png' %}" alt="Tarjeta" class="metodo-icon tarjeta-icon">
                                            <span class="metodo-text">Tarjeta Nacional</span>
                                        {% elif tipo.nombre == "Tarjeta Internacional" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/3.Internacional.png' %}" alt="Internacional" class="metodo-icon internacional-icon">
                                            <span class="metodo-text">Tarjeta Internacional</span>
                                        {% elif tipo.nombre == "Cuenta Bancaria" or tipo.nombre == "Transferencia" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/4.Transferencia.png' %}" alt="Transferencia" class="metodo-icon transferencia-icon">
                                            <span class="metodo-text">Transferencia</span>
                                        {% elif tipo.nombre == "Billetera" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/5.Billetera.png' %}" alt="Billetera" class="metodo-icon billetera-icon">
                                            <span class="metodo-text">Billetera</span>
                                        {% else %}
                                            <span class="metodo-text">{{ tipo.nombre }}</span>
                                        {% endif %}
                                    </button>
                                {% endfor %}
                                </div>

                                <div class="select-wrapper metodo-select-wrapper metodo-select-expanded" id="pago-select-wrapper">
                                    <select id="simu-metodo-pago" name="medio_pago" class="metodo-select metodo-select-white">
                                        <option value="" disabled selected>Selecciona una opci√≥n</option>
                                    </select>
                                    <svg class="metodo-select-arrow metodo-select-arrow-dark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                        <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" />
                                    </svg>
                                </div>
                                
                                <button type="button" class="metodo-btn-atras" id="pago-btn-atras">Atr√°s</button>
                            </div>
                            
                            <!-- Datos de cuenta bancaria para transferencia -->
                            <div id="transferencia-info" class="transferencia-info d-none">
                                <div class="transferencia-card datos-transferencia-container">
                                    <h6 class="transferencia-titulo">Datos para transferencia</h6>
                                    <div class="transferencia-datos">
                                        <p class="mb-1"><strong>Titular:</strong> Global Exchange </p>
                                        <p class="mb-1"><strong>RUC:</strong> 80012345-6 </p>
                                        <p class="mb-1"><strong>Banco:</strong> {{cuenta_negocio.entidad.nombre}}</p>
                                        <p class="mb-1"><strong>Cuenta:</strong> {{cuenta_negocio.numero_cuenta}}</p>
                                        <p class="mb-1"><strong>Alias:</strong> {{cuenta_negocio.alias_cbu}}</p>
                                    </div>
                                    <p class="transferencia-nota">Por favor, una vez registrada la operaci√≥n selecciona "Continuar Pago".</p>
                                </div>
                            </div>
                        </div>

                        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                             COLUMNA 3: Medio de Cobro
                             ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
                        <div class="converter-column column-cobro">
                            <p class="converter-subtitle">¬øC√≥mo quiere cobrar?</p>
                            
                            <div class="converter-field-content metodo-content" id="cobro-content">
                                <div class="tab-row metodo-tabs" id="cobro-tabs">
                                {% for tipo in tipos_cobro %}
                                    <button type="button" class="tab-btn metodo-btn {% if forloop.first %}active{% endif %}" data-tipo-general="{{ tipo.id }}" data-tipo-nombre="{{ tipo.nombre }}">
                                        {% if tipo.nombre == "Tauser" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/1.Tauser.png' %}" alt="Tauser" class="metodo-icon tauser-icon">
                                            <span class="metodo-text">Tauser (TAS)</span>
                                        {% elif tipo.nombre == "Cuenta Bancaria" or tipo.nombre == "Transferencia" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/4.Transferencia.png' %}" alt="Transferencia" class="metodo-icon transferencia-icon">
                                            <span class="metodo-text">Cuenta Bancaria</span>
                                        {% elif tipo.nombre == "Billetera" %}
                                            <img src="{% static 'webapp/pantalla_compra_venta/5.Billetera.png' %}" alt="Billetera" class="metodo-icon billetera-icon">
                                            <span class="metodo-text">Billetera</span>
                                        {% else %}
                                            <span class="metodo-text">{{ tipo.nombre }}</span>
                                        {% endif %}
                                    </button>
                                {% endfor %}
                                </div>
                                
                                <div class="select-wrapper metodo-select-wrapper metodo-select-expanded" id="cobro-select-wrapper">
                                    <select id="simu-metodo-cobro" name="medio_cobro" class="metodo-select metodo-select-white">
                                        <option value="" disabled selected>Selecciona una opci√≥n</option>
                                    </select>
                                    <svg class="metodo-select-arrow metodo-select-arrow-dark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                                        <path d="M6 9l6 6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" fill="none" />
                                    </svg>
                                </div>
                                
                                <button type="button" class="metodo-btn-atras" id="cobro-btn-atras">Atr√°s</button>
                            </div>
                        </div>
                        {% endif %}

                    </div>
                </div>

                    <input type="hidden" id="input-tipo" name="tipo">
                    <input type="hidden" id="input-moneda-origen" name="moneda_origen">
                    <input type="hidden" id="input-moneda-destino" name="moneda_destino">
                    <input type="hidden" id="input-monto-origen" name="monto_origen">
                    <input type="hidden" id="input-monto-destino" name="monto_destino">
                    <input type="hidden" id="input-tasa-cambio" name="tasa_cambio">
                    <input type="hidden" id="input-medio-pago-contenttype" name="medio_pago_contenttype">
                    <input type="hidden" id="input-medio-cobro-contenttype" name="medio_cobro_contenttype">
                    <input type="hidden" id="input-medio-pago-tipo" name="medio_pago_tipo">
                    <input type="hidden" id="input-medio-cobro-tipo" name="medio_cobro_tipo">
            </div>
            <div class="continuar-container">
                <button type="button" id="next-step" class="metodo-btn">
                    <span class="metodo-text">Continuar</span>
                </button>
            </div>
        </div>
         <!-- üÜï PASO 2: Revisi√≥n -->
        <div id="step-2" class="wizard-step d-none">
            <h4>Revisi√≥n y Confirmaci√≥n</h4>
            <p>Verific√° los detalles antes de confirmar tu operaci√≥n.</p>
            <hr>

            <ul class="list-group mb-3">
                <li class="list-group-item d-flex justify-content-between">
                <strong>Tipo de operaci√≥n:</strong> <span id="resumen-tipo"></span>
                </li>
                <li class="list-group-item d-flex justify-content-between">
                <strong>Monto origen:</strong> <span id="resumen-origen"></span>
                </li>
                <li class="list-group-item d-flex justify-content-between">
                <strong>Monto destino:</strong> <span id="resumen-destino"></span>
                </li>
                <li class="list-group-item d-flex justify-content-between">
                <strong>M√©todo de pago:</strong> <span id="resumen-pago"></span>
                </li>
                <li class="list-group-item d-flex justify-content-between">
                <strong>M√©todo de cobro:</strong> <span id="resumen-cobro"></span>
                </li>
            </ul>

            <div class="converter-actions d-flex justify-content-between mt-3">
                <button type="button" id="prev-step" class="btn btn-secondary">Atr√°s</button>
                <button name="confirmar" type="submit" class="btn btn-success">Confirmar operaci√≥n</button>
            </div>
        </div>

    </form>

    {% if resultado %}
        <div class="alert alert-success mt-4">
            <strong>Resultado:</strong> {{ resultado }}
        </div>
    {% endif %}
</div>

<script>
(async function() {
    const amount = document.getElementById("simu-amount");
    const from = document.getElementById("simu-from");
    const to = document.getElementById("simu-to");
    const intercambiar = document.getElementById("simu-intercambiar");
    const out = document.getElementById("simu-result-main");
    const detail = document.getElementById("simu-result-detail");
    const metodoPago = document.getElementById("simu-metodo-pago");
    const metodoCobro = document.getElementById("simu-metodo-cobro");
    const LIMITES_INTERCAMBIO = JSON.parse('{{ limites_intercambio|safe }}');
    const TAUSER_CT_ID = {{ ct_tauser.id }};

    let TAUSER_STOCK = {}; // { tauserId : { "USD": [{value, qty}, ...], ... } }

    let CODES = [];
    const META = Object.create(null);

    // Flag para prevenir clicks m√∫ltiples en el bot√≥n intercambiar
    let isSwapping = false;

    // Referencias a elementos del dropdown personalizado
    const fromFlag = document.getElementById("simu-from-flag");
    const toFlag = document.getElementById("simu-to-flag");
    const fromCodeSpan = document.getElementById("simu-from-code");
    const toCodeSpan = document.getElementById("simu-to-code");
    const btnFrom = document.getElementById("btn-from");
    const btnTo = document.getElementById("btn-to");
    const menuFrom = document.getElementById("menu-from");
    const menuTo = document.getElementById("menu-to");

    // ===========================
    // CUSTOM DROPDOWN LOGIC
    // ===========================
    
    // Toggle men√∫ al hacer clic en el bot√≥n
    btnFrom.addEventListener("click", (e) => {
        e.stopPropagation();
        menuTo.classList.remove("open");
        menuFrom.classList.toggle("open");
    });
    
    btnTo.addEventListener("click", (e) => {
        e.stopPropagation();
        menuFrom.classList.remove("open");
        menuTo.classList.toggle("open");
    });
    
    // Cerrar men√∫s al hacer clic fuera
    document.addEventListener("click", () => {
        menuFrom.classList.remove("open");
        menuTo.classList.remove("open");
    });
    
    // Funci√≥n para construir las opciones del men√∫ dropdown
    function buildDropdownMenu(menuEl, selectEl, codeSpan, flagImg, excludeCode = null) {
        menuEl.innerHTML = "";
        
        CODES.forEach(code => {
            if (excludeCode && code === excludeCode) return; // Excluir la moneda del otro dropdown
            
            const option = document.createElement("div");
            option.className = "currency-dropdown-option";
            if (code === selectEl.value) option.classList.add("selected");
            option.dataset.code = code;
            
            const flagUrl = META[code]?.flag_url || "";
            option.innerHTML = `
                <img src="${flagUrl}" alt="${code}" class="option-flag" onerror="this.style.display='none'">
                <span class="option-code">${code}</span>
            `;
            
            option.addEventListener("click", (e) => {
                e.stopPropagation();
                
                // Actualizar el select oculto
                selectEl.value = code;
                
                // Actualizar el bot√≥n visible
                codeSpan.textContent = code;
                if (flagImg && META[code]?.flag_url) {
                    flagImg.src = META[code].flag_url;
                    flagImg.style.display = 'block';
                }
                
                // Cerrar el men√∫
                menuEl.classList.remove("open");
                
                // Disparar evento change para mantener la l√≥gica existente
                selectEl.dispatchEvent(new Event("change"));
            });
            
            menuEl.appendChild(option);
        });
    }
    
    // Funci√≥n para actualizar la UI del dropdown desde el select
    function updateDropdownUI() {
        const fromValue = from.value;
        const toValue = to.value;
        
        // Actualizar bot√≥n FROM
        fromCodeSpan.textContent = fromValue || "---";
        if (fromFlag && META[fromValue]?.flag_url) {
            fromFlag.src = META[fromValue].flag_url;
            fromFlag.style.display = 'block';
        } else if (fromFlag) {
            fromFlag.style.display = 'none';
        }
        
        // Actualizar bot√≥n TO
        toCodeSpan.textContent = toValue || "---";
        if (toFlag && META[toValue]?.flag_url) {
            toFlag.src = META[toValue].flag_url;
            toFlag.style.display = 'block';
        } else if (toFlag) {
            toFlag.style.display = 'none';
        }
        
        // Actualizar placeholders din√°micamente
        if (amount) {
            amount.placeholder = `0 ${fromValue || 'USD'}`;
        }
        if (out) {
            out.placeholder = `0 ${toValue || 'PYG'}`;
        }
        
        // Reconstruir men√∫s excluyendo la moneda seleccionada en el otro dropdown
        // Esto previene que el usuario seleccione la misma moneda en ambos
        buildDropdownMenu(menuFrom, from, fromCodeSpan, fromFlag, toValue);
        buildDropdownMenu(menuTo, to, toCodeSpan, toFlag, fromValue);
    }

    function nf(value, currencyCode) {
        // Determina cu√°ntos decimales mostrar seg√∫n la moneda
        // Si es "PYG" (guaran√≠ paraguayo), se usan 0 decimales
        // Si no, busca en el objeto META[currencyCode] la propiedad "decimals"
        // y si no existe, usa por defecto 2 decimales
        const decimals = currencyCode === "PYG" ? 0 : (META[currencyCode]?.decimals ?? 2);

        // Crea un formateador num√©rico con configuraci√≥n regional "es-ES"
        // y fija la cantidad de decimales al valor calculado arriba
        return new Intl.NumberFormat("es-ES", {
            minimumFractionDigits: decimals,
            maximumFractionDigits: decimals
        }).format(value); // Aplica el formateador al n√∫mero recibido
    }

    // Funci√≥n para extraer solo el n√∫mero de un valor que puede incluir c√≥digo de moneda
    // Ej: "1.234,56 USD" -> 1234.56
    function extractNumber(text) {
        if (!text) return NaN;
        // Elimina cualquier c√≥digo de moneda (letras al final)
        const numericPart = text.replace(/[A-Za-z\s]+$/g, "").trim();
        // Convierte formato espa√±ol (1.234,56) a formato num√©rico (1234.56)
        return parseFloat(
            numericPart
                .replace(/\./g, "")   // elimina puntos de miles
                .replace(",", ".")    // reemplaza coma decimal por punto
        );
    }

    // Funci√≥n para formatear un input con su c√≥digo de moneda
    function formatWithCurrency(inputEl, currencyCode) {
        const num = extractNumber(inputEl.value);
        if (!isNaN(num) && num > 0) {
            inputEl.value = `${nf(num, currencyCode)} ${currencyCode}`;
        }
    }

    function buildOptions(selectEl, preferCode) {
        // Limpia el contenido actual del <select>
        selectEl.innerHTML = "";

        // Recorre la lista de c√≥digos de moneda definida en CODES
        CODES.forEach(code => {
            // Crea una opci√≥n <option> para el select
            const opt = document.createElement("option");
            opt.value = code; // el valor de la opci√≥n ser√° el c√≥digo de moneda

            // Mostrar solo el c√≥digo de 3 letras (USD, EUR, PYG, etc.)
            opt.textContent = code;

            // Agrega la opci√≥n al <select>
            selectEl.appendChild(opt);
        });

        // Selecciona por defecto el c√≥digo preferido si existe y est√° en CODES
        if (preferCode && CODES.includes(preferCode)) 
            selectEl.value = preferCode;
        // Si no hay preferencia v√°lida, selecciona el primer c√≥digo disponible
        else if (CODES.length) 
            selectEl.value = CODES[0];
        
        // Actualiza el dropdown UI despu√©s de construir las opciones
        updateDropdownUI();
    }

    // variables y listeners utilizados en enforceDifferent()
    let lastFrom = from.value;
    let lastTo = to.value;

    from.addEventListener("focus", () => lastFrom = from.value);
    to.addEventListener("focus", () => lastTo = to.value);
    
    // Actualizar dropdown UI cuando cambia la selecci√≥n
    from.addEventListener("change", updateDropdownUI);
    to.addEventListener("change", updateDropdownUI);

    function enforceDifferent(changed, other) {
        // Validaci√≥n de seguridad: si de alguna manera ambas monedas son iguales
        // (no deber√≠a ocurrir porque las opciones est√°n filtradas en el dropdown)
        if (from.value === to.value) {
            // Cambiar el otro a una moneda diferente
            const fallback = from.value === "PYG" ? "USD" : "PYG";
            if (changed === from) {
                to.value = fallback;
            } else {
                from.value = fallback;
            }
            updateDropdownUI();
            return;
        }

        // Caso: si ninguno es PYG (ambas son divisas extranjeras)
        // Solo se permiten conversiones con Guaran√≠es
        if (from.value !== "PYG" && to.value !== "PYG") {
            // el que no cambi√≥ se fuerza a PYG
            if (changed === from) to.value = "PYG";
            else from.value = "PYG";
            
            // Actualizar la UI del dropdown
            updateDropdownUI();
        }
    }
    
    function compute() {
        // Convierte el valor ingresado en el campo "amount" a n√∫mero decimal.
        const rawText = amount.value || "";
        const raw = extractNumber(rawText);

        // Si no es un n√∫mero v√°lido o es menor/igual a 0, muestra un mensaje de error.
        if (isNaN(raw) || raw <= 0) {
            out.value = ""; // vac√≠o para mostrar el placeholder
            detail.textContent = "Ingres√° un monto para calcular"; // mensaje para el usuario
            return; // corta la ejecuci√≥n
        }

        // Obtiene las monedas seleccionadas (desde y hacia)
        const a = from.value, b = to.value;

        // Verifica que ambas monedas existan en META (tabla con cotizaciones/definiciones)
        if (!META[a] || !META[b]) return;

        // Variables donde se guardar√°n el resultado y la tasa de cambio usada
        let val, rateAB;

        // Caso 1: convertir de Guaran√≠es (PYG) a otra moneda
        if (a === "PYG" && b !== "PYG") {
            val = raw / META[b].venta;   // Divide el monto en PYG por la tasa de venta de la moneda destino
            rateAB = META[b].venta;  // Calcula el tipo de cambio unitario
            detail.innerHTML = `1 ${b} = ${nf(rateAB, "PYG")} ${a}`; // Muestra el detalle de la tasa usada
        } 
        // Caso 2: convertir de otra moneda hacia Guaran√≠es
        else if (a !== "PYG" && b === "PYG") {
            val = raw * META[a].compra;  // Multiplica el monto por la tasa de compra de la moneda origen
            rateAB = META[a].compra;     // Guarda la tasa usada
            detail.innerHTML = `1 ${a} = ${nf(rateAB, "PYG")} ${b}`; // Muestra el detalle de la tasa
        } 
        // Caso inv√°lido: cuando se intenta convertir entre dos monedas que no son PYG
        else {
            out.value = ""; // vac√≠o para mostrar el placeholder
            detail.textContent = "S√≥lo se permiten conversiones con Guaran√≠es"; 
            return;
        }

        // Muestra el resultado formateado en el campo de salida
        out.value = `${nf(val, b)} ${b}`;
        
        // NO formateamos amount aqu√≠ - eso interfiere con la escritura del usuario
        // El formateo de amount se hace solo en el evento blur

    }

    function attachListeners() {
        // Listener para quitar el c√≥digo de moneda y formato al hacer focus en amount
        amount.addEventListener("focus", () => {
            // Extraer el valor num√©rico limpio del campo formateado
            // Ej: "1.234.567 USD" -> "1234567"
            const text = amount.value || "";
            // Primero quitar el c√≥digo de moneda
            const sinMoneda = text.replace(/\s+[A-Za-z]{2,4}$/g, "").trim();
            // Luego quitar los puntos de miles (formato es-ES)
            const valorLimpio = sinMoneda.replace(/\./g, "");
            // Mostrar solo el n√∫mero limpio para edici√≥n
            amount.value = valorLimpio;
        });

        // Listener para agregar el c√≥digo de moneda al salir de amount
        amount.addEventListener("blur", () => {
            const num = extractNumber(amount.value);
            if (!isNaN(num) && num > 0) {
                amount.value = `${nf(num, from.value)} ${from.value}`;
            }
        });

        // Agrega listeners a los campos de monto, moneda origen y moneda destino.
        // Se escucha tanto "input" (cuando el usuario escribe) como "change" (cuando cambia el valor).
        ["input","change"].forEach(evt => {
            // Cuando se modifica el monto, recalcula directamente
            amount.addEventListener(evt, () => {
                actualizarFiltros(false); // üîπ actualiza visibilidad de botones SIN colapsar selecciones
                compute();

                aplicarFiltroTauserEnSelect(metodoPago, true);
                aplicarFiltroTauserEnSelect(metodoCobro, false);

                // ‚úÖ Si el m√©todo seleccionado es Tauser ‚Üí evaluar
                const opt = metodoPago?.selectedOptions?.[0];
                if (opt && opt.dataset.contentTypeId == TAUSER_CT_ID) {
                    evaluarSugerenciaTauser(metodoPago, true);
                }

                evaluarAmbosTausers();

            });

            // Cuando cambia la moneda de origen (from)
            from.addEventListener(evt, async () => {
                enforceDifferent(from,to);     // fuerza que origen y destino no sean iguales
                actualizarFiltros();           // üîπ antes de recargar m√©todos, actualiza botones
                await recargarMetodos();       // recarga m√©todos de pago/cobro disponibles
                compute();                     // recalcula el resultado

                aplicarFiltroTauserEnSelect(metodoPago, true);
                aplicarFiltroTauserEnSelect(metodoCobro, false);

                // evaluar pago tauser
                const optP = metodoPago?.selectedOptions?.[0];
                if (optP && optP.dataset.contentTypeId == TAUSER_CT_ID) {
                    evaluarSugerenciaTauser(metodoPago, true);
                }

                const optC = metodoCobro?.selectedOptions?.[0];
                if (optC && optC.dataset.contentTypeId == TAUSER_CT_ID) {
                    evaluarSugerenciaTauser(metodoCobro, false);
                }

                evaluarAmbosTausers();

            });

            // Cuando cambia la moneda de destino (to)
            to.addEventListener(evt, async () => {
                enforceDifferent(to,from);     // igual que arriba, pero para destino
                actualizarFiltros();           // actualizar botones de filtros disponibles
                await recargarMetodos();       // recarga m√©todos
                compute();                     // recalcula

                aplicarFiltroTauserEnSelect(metodoPago, true);
                aplicarFiltroTauserEnSelect(metodoCobro, false);

                // evaluar pago tauser
                const optP = metodoPago?.selectedOptions?.[0];
                if (optP && optP.dataset.contentTypeId == TAUSER_CT_ID) {
                    evaluarSugerenciaTauser(metodoPago, true);
                }

                const optC = metodoCobro?.selectedOptions?.[0];
                if (optC && optC.dataset.contentTypeId == TAUSER_CT_ID) {
                    evaluarSugerenciaTauser(metodoCobro, false);
                }

                evaluarAmbosTausers();

            });
        });

        // Listener para el bot√≥n de "intercambiar" monedas
        intercambiar.addEventListener("click", async () => {
            // Prevenir clicks m√∫ltiples mientras se procesa
            if (isSwapping) return;
            isSwapping = true;

            try {
                // Extraer los n√∫meros de los campos (sin c√≥digos de moneda)
                const numAmount = extractNumber(amount.value);
                const numOut = extractNumber(out.value);

                // Intercambia los valores de las monedas (selects ocultos)
                const tmpCurrency = from.value; 
                from.value = to.value; 
                to.value = tmpCurrency;

                // Intercambia los n√∫meros y los formatea con los nuevos c√≥digos de moneda
                // El valor de amount (que era moneda FROM) ahora es moneda TO
                // El valor de out (que era moneda TO) ahora es moneda FROM
                if (!isNaN(numOut) && numOut > 0) {
                    amount.value = `${nf(numOut, from.value)} ${from.value}`;
                } else {
                    amount.value = "";
                }
                
                if (!isNaN(numAmount) && numAmount > 0) {
                    out.value = `${nf(numAmount, to.value)} ${to.value}`;
                } else {
                    out.value = "";
                }

                // Guardar los valores intercambiados antes de recargar m√©todos
                const savedAmountValue = amount.value;
                const savedOutValue = out.value;

                // Actualiza la interfaz visual (banderas, c√≥digos, placeholders)
                updateDropdownUI();

                enforceDifferent(from,to);     // asegura que no queden iguales
                
                // üîÑ RESET: Al intercambiar, colapsar secciones y resetear selecciones
                actualizarFiltros(true);       // Colapsa secciones y resetea visibilidad de botones
                
                // Resetear los selectores de m√©todos al placeholder
                if (metodoPago) {
                    metodoPago.selectedIndex = 0;
                }
                if (metodoCobro) {
                    metodoCobro.selectedIndex = 0;
                }
                
                await recargarMetodos(null, false);       // recarga m√©todos SIN preservar selecciones
                
                // Restaurar los valores intercambiados (recargarMetodos llama compute que los sobrescribe)
                amount.value = savedAmountValue;
                out.value = savedOutValue;
            } finally {
                // Permitir nuevo click despu√©s de completar
                isSwapping = false;
            }
        });

        // Si existen selectores de m√©todos de pago y cobro, agrega listeners
        if (metodoPago && metodoCobro) {
            [metodoPago, metodoCobro].forEach(selectEl => {
                selectEl.addEventListener("change", async () => {

                    // üü£ Detectar botones activos
                    const activoPago = document.querySelector("#pago-tabs .tab-btn.active");
                    const activoCobro = document.querySelector("#cobro-tabs .tab-btn.active");

                    const textoPago = activoPago?.textContent?.trim().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
                    const textoCobro = activoCobro?.textContent?.trim().normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();

                    const ambosTauser = textoPago === "tauser" && textoCobro === "tauser";

                    // Solo sincroniza si ambos tabs activos son "Tauser"
                    if (ambosTauser) {
                        const origen = selectEl;
                        const destino = selectEl === metodoPago ? metodoCobro : metodoPago;

                        const valorSeleccionado = origen.value;

                        // Aplica el mismo valor al otro select si existe esa opci√≥n
                        const match = [...destino.options].find(opt => opt.value === valorSeleccionado);
                        if (match) {
                            destino.value = match.value;

                            // (opcional) Efecto visual para notificar cambio
                            destino.classList.add("highlight-sync");
                            setTimeout(() => destino.classList.remove("highlight-sync"), 800);
                        }
                    }

                    await updateRatesForMetodo();
                    compute();

                    aplicarFiltroTauserEnSelect(metodoPago, true);
                    aplicarFiltroTauserEnSelect(metodoCobro, false);

                    const esPago = (selectEl === metodoPago);
                    const opt = selectEl.selectedOptions?.[0];
                    if (opt && opt.dataset.contentTypeId == TAUSER_CT_ID) {
                        evaluarSugerenciaTauser(selectEl, esPago);
                    }

                    evaluarAmbosTausers();

                });
            });
        }
    }

    async function updateRatesForMetodo() {
        try {
            // Si no existen los selectores de m√©todo de pago o cobro, no hace nada
            if (!metodoPago || !metodoCobro) return;

            // Funci√≥n para obtener el "tipo general" del bot√≥n activo (pago o cobro)
            const getTipoGeneral = (tipo) => {
                // Seg√∫n el par√°metro recibido ("pago" o "cobro"), seleccionamos el bot√≥n activo del grupo correspondiente
                const selector = tipo === "pago"
                    ? "#pago-tabs .tab-btn.active"   // Busca el bot√≥n activo dentro del grupo de Pago
                    : "#cobro-tabs .tab-btn.active"; // Busca el bot√≥n activo dentro del grupo de Cobro

                // Devuelve el valor del atributo data-tipo-general del bot√≥n activo,
                // o cadena vac√≠a si no existe o a√∫n no hay un bot√≥n activo
                return document.querySelector(selector)?.dataset.tipoGeneral || "";
            };

            // Obtiene el tipo general del m√©todo de pago seleccionado
            // (proviene del bot√≥n activo en la secci√≥n "Pagar con")
            const pagoId = getTipoGeneral("pago");

            // Obtiene el tipo general del m√©todo de cobro seleccionado
            // (proviene del bot√≥n activo en la secci√≥n "Recibir en")
            const cobroId = getTipoGeneral("cobro");

            // Construye la URL hacia la API de monedas, pasando los IDs como query params
            const url = `{% url 'api_currencies' %}?tipo_metodo_pago_id=${pagoId}&tipo_metodo_cobro_id=${cobroId}`;
            
            // Llama a la API (sin cachear) para obtener las tasas actualizadas
            const res = await fetch(url, { cache:"no-store" });
            const payload = await res.json();

            // Extrae los items del JSON, o lista vac√≠a si no existe
            const items = payload.items || [];
            const byCode = {};

            // Convierte la lista de items en un diccionario indexado por el c√≥digo de moneda
            items.forEach(it => byCode[it.code] = it);

            // Si la API no incluy√≥ PYG, se asegura de a√±adirlo manualmente con valores neutros
            if (!byCode["PYG"]) 
                byCode["PYG"] = { code:"PYG", name:"Guaran√≠", decimals:0, venta:1.0, compra:1.0 };

            // Ordena los c√≥digos: PYG siempre primero, luego orden alfab√©tico
            CODES = Object.keys(byCode).sort((a,b)=> 
                a==="PYG"?-1 : b==="PYG"?1 : a.localeCompare(b)
            );

            // Actualiza el diccionario global META con la info por cada c√≥digo
            CODES.forEach(code => META[code] = byCode[code]);

            // Recalcula inmediatamente la conversi√≥n con las tasas nuevas
            compute();

        } catch(e) {
            // Si algo falla, loguea el error en consola
            console.error("Error al actualizar tasas:", e);
        }
    }

    async function recargarMetodos(tipo = null, preservarSeleccion = true) {
        // Si no existen los selectores de m√©todo de pago o cobro, no hace nada
        if (!metodoPago || !metodoCobro) return;

        try {
            // Obtiene las referencias de los grupos de botones de tipo general
            const pagoTabs = document.getElementById("pago-tabs");
            const cobroTabs = document.getElementById("cobro-tabs");

            // Detecta qu√© bot√≥n est√° activo en cada grupo
            const tipoGeneralPago = pagoTabs?.querySelector(".tab-btn.active")?.dataset.tipoGeneral || null;
            const tipoGeneralCobro = cobroTabs?.querySelector(".tab-btn.active")?.dataset.tipoGeneral || null;

            // Llama a la API que devuelve los m√©todos disponibles seg√∫n la conversi√≥n seleccionada
            const res = await fetch(`{% url 'get_metodos_pago_cobro' %}?from=${from.value}&to=${to.value}`);
            const data = await res.json(); // Parseo del JSON de respuesta

            // ‚úÖ Guardar stock de Tausers
            TAUSER_STOCK = {};
            [...data.metodo_pago, ...data.metodo_cobro].forEach(item => {
                if (item.tipo === "Tauser" && item.stock) {
                    TAUSER_STOCK[item.id] = item.stock; 
                }
            });

            // ‚úÖ Dar PYG infinito a todos los Tausers (para stock)
            for (const tauserId in TAUSER_STOCK) {

                // Si no tiene PYG en su estructura, crearla
                if (!TAUSER_STOCK[tauserId]["PYG"]) {
                    TAUSER_STOCK[tauserId]["PYG"] = [];
                }

                // A√±adir un ‚Äúbillete‚Äù enorme que act√∫a como infinito
                TAUSER_STOCK[tauserId]["PYG"].push({
                    value: 1000000000, // 1.000.000.000 Gs
                    quantity: Infinity
                });
            }

            // üÜï Opci√≥n inicial por defecto
            const agregarOpcionInicial = (selectEl) => {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "Selecciona una opci√≥n";
                opt.disabled = true;
                opt.selected = true;
                selectEl.appendChild(opt);
            };

            // Funci√≥n auxiliar para crear un <option> a partir de un item recibido
            const crearOption = (item) => {
                const opt = document.createElement("option");
                opt.value = item.id; // el valor ser√° el id del m√©todo
                opt.dataset.tipoGeneral = item.tipo_general_id || ""; // guarda el tipo general en dataset

                // Seg√∫n el tipo de m√©todo, construye el texto visible en el select

                opt.textContent = item.nombre; // caso por defecto

                // Se guarda tambi√©n el content_type_id (para identificar modelo origen en backend)
                opt.dataset.contentTypeId = item.content_type_id || "";

                return opt; // devuelve el <option> ya construido
            };

            // üü© === Filtro y actualizaci√≥n seg√∫n el tipo recibido ===
            // Guardar selecci√≥n previa solo si preservarSeleccion es true
            const prevPagoSeleccionado = preservarSeleccion ? metodoPago.value : null;
            const prevCobroSeleccionado = preservarSeleccion ? metodoCobro.value : null;
            if (tipo === null || tipo === "pago") {
                // üßπ Limpia completamente las opciones actuales del <select> de m√©todos de pago
                metodoPago.innerHTML = "";

                // üîπ Agrega una opci√≥n inicial tipo placeholder ("---Seleccione una opci√≥n---")
                agregarOpcionInicial(metodoPago);

                // üß† Filtra los m√©todos de pago seg√∫n el tipo general activo (bot√≥n del tab seleccionado)
                // Si no hay tipo activo, se incluyen todos los m√©todos.
                const metodosPagoFiltrados = data.metodo_pago.filter(
                    (m) => !tipoGeneralPago || m.tipo_general_id == tipoGeneralPago
                );

                // üîß Crea y agrega cada <option> correspondiente a los m√©todos filtrados
                metodosPagoFiltrados.forEach(item => metodoPago.appendChild(crearOption(item)));

                // üéØ Intentar restaurar la selecci√≥n anterior si a√∫n existe
                if (prevPagoSeleccionado) {
                    const existePrev = [...metodoPago.options].some(opt => opt.value === prevPagoSeleccionado);
                    if (existePrev) {
                        metodoPago.value = prevPagoSeleccionado;
                    } else if (metodoPago.options.length) {
                        metodoPago.selectedIndex = 0;
                    }
                } else if (metodoPago.options.length) {
                    metodoPago.selectedIndex = 0;
                }
            }

            if (tipo === null || tipo === "cobro") {
                // üßπ Limpia las opciones actuales del <select> de m√©todos de cobro
                metodoCobro.innerHTML = "";

                // üîπ Agrega la opci√≥n inicial vac√≠a ("---Seleccione una opci√≥n---")
                agregarOpcionInicial(metodoCobro);

                // üß† Filtra los m√©todos de cobro seg√∫n el tipo general activo (bot√≥n del tab seleccionado)
                // Si no hay tipo activo, se incluyen todos los m√©todos.
                const metodosCobroFiltrados = data.metodo_cobro.filter(
                    (m) => !tipoGeneralCobro || m.tipo_general_id == tipoGeneralCobro
                );

                // üîß Crea y agrega cada <option> correspondiente a los m√©todos filtrados
                metodosCobroFiltrados.forEach(item => metodoCobro.appendChild(crearOption(item)));

                // üéØ Intentar restaurar la selecci√≥n anterior si a√∫n existe
                if (prevCobroSeleccionado) {
                    const existePrevC = [...metodoCobro.options].some(opt => opt.value === prevCobroSeleccionado);
                    if (existePrevC) {
                        metodoCobro.value = prevCobroSeleccionado;
                    } else if (metodoCobro.options.length) {
                        metodoCobro.selectedIndex = 0;
                    }
                } else if (metodoCobro.options.length) {
                    metodoCobro.selectedIndex = 0;
                }
            }

            // Luego de recargar m√©todos, actualiza las tasas de cambio
            await updateRatesForMetodo();

            aplicarFiltroTauserEnSelect(metodoPago, true);
            aplicarFiltroTauserEnSelect(metodoCobro, false);

            // Tras recargar selects, evaluar si hay tauser seleccionado
            const optP = metodoPago?.selectedOptions?.[0];
            if (optP && optP.dataset.contentTypeId == TAUSER_CT_ID) {
                evaluarSugerenciaTauser(metodoPago, true);
            }
            const optC = metodoCobro?.selectedOptions?.[0];
            if (optC && optC.dataset.contentTypeId == TAUSER_CT_ID) {
                evaluarSugerenciaTauser(metodoCobro, false);
            }

            evaluarAmbosTausers();

        } catch (error) {
            // Si algo falla (error de red o API), lo muestra en consola
            console.error("Error al cargar m√©todos de pago/cobro:", error);
        }
    }

    async function boot() {
        try {
            // Construye las opciones de los selectores de monedas
            // Por defecto: "from" empieza con USD y "to" con PYG
            buildOptions(from, "USD");
            buildOptions(to, "PYG");

            // Estado inicial de los botones de filto de los m√©todos
            actualizarFiltros();

            // Carga inicialmente las tasas de cambio seg√∫n los m√©todos de pago/cobro seleccionados
            await updateRatesForMetodo();

            // Asegura que origen y destino no sean iguales
            enforceDifferent(from, to);

            // Calcula inmediatamente la conversi√≥n con esos valores iniciales
            compute();
        } catch(e) {
            // Si algo falla (API, construcci√≥n de selects, etc.), muestra un error en consola
            console.error("No se pudieron cargar monedas:", e);
        }

        // Finalmente, recarga la lista de m√©todos de pago/cobro disponibles
        await recargarMetodos();
    }

    // Cuando el DOM est√° listo...
    document.addEventListener("DOMContentLoaded", async () => {
        // Conecta todos los listeners (inputs, selects, botones)
        attachListeners();

        // Primero carga los m√©todos de pago/cobro iniciales desde el backend
        await recargarMetodos();

        // Filtra los m√©todos de cobro y pago seg√∫n el tipo general seleccionado
        configurarTabsFiltro()

        // Ejecuta el arranque inicial (boot) para dejar todo preparado
        boot();
    });


////////////////////////////////////////////////////////////////////////////////////////////////////////
//Conversor del input
///////////////////////////////////////////////////////////////////////////////////////////////////////

    document.addEventListener("DOMContentLoaded", function () {
        const input = document.getElementById("simu-amount");

        // üîß NO formateamos en tiempo real durante la edici√≥n para preservar la posici√≥n del cursor.
        // El formateo se aplica solo en el evento 'blur' (definido en attachListeners).
        // Durante la edici√≥n, solo permitimos d√≠gitos sin formatear.
        
        input.addEventListener("input", function (e) {
            // Solo permitir d√≠gitos, sin reformatear (para preservar posici√≥n del cursor)
            // Guardar posici√≥n actual del cursor
            const cursorPos = this.selectionStart;
            const valorAnterior = this.value;
            
            // Eliminar caracteres no num√©ricos
            let value = e.target.value.replace(/\D/g, "");
            
            // Si el valor cambi√≥, actualizar y restaurar cursor
            if (value !== valorAnterior) {
                e.target.value = value;
                // Calcular nueva posici√≥n del cursor (ajustar por caracteres eliminados)
                const diferencia = valorAnterior.length - value.length;
                const nuevaPos = Math.max(0, cursorPos - diferencia);
                this.setSelectionRange(nuevaPos, nuevaPos);
            }
        });

        // Evita pegar texto con caracteres no num√©ricos
        input.addEventListener("paste", function (e) {
            const paste = (e.clipboardData || window.clipboardData).getData("text");
            // Permitir pegar solo si contiene n√∫meros (limpiaremos en input)
            // No bloqueamos, dejamos que el evento input limpie
        });
    });


////////////////////////////////////////////////////////////////////////////////////////////////////////
//L√≥gica de comportamiento de los botones de filtro de los selects de m√©todos de pago y cobro
///////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Actualiza los botones de filtro de m√©todos de pago y cobro
     * seg√∫n las divisas seleccionadas y el monto ingresado.
     *
     * Reglas:
     * 1. Pago: Si `from` ‚â† PYG ‚Üí solo "Tauser" y "Tarjeta Internacional".
     * 2. Cobro: Si `to` ‚â† PYG ‚Üí solo "Tauser".
     * 3. Si `to` = PYG y monto no es m√∫ltiplo de 100000 ‚Üí ocultar "Tauser".
     *
     * @param {boolean} colapsarSecciones - Si es true, colapsa las secciones expandidas.
     *        Pasar false cuando solo cambia el monto para preservar selecciones.
     */
    function actualizarFiltros(colapsarSecciones = true) {
        const amountEl = document.getElementById("simu-amount");
        const fromEl = document.getElementById("simu-from");
        const toEl = document.getElementById("simu-to");
        const pagoContent = document.getElementById("pago-content");
        const cobroContent = document.getElementById("cobro-content");

        const amount = parseFloat(amountEl?.value?.replace(/\./g, "")) || 0;
        const from = fromEl?.value?.trim() || "";
        const to = toEl?.value?.trim() || "";

        const pagoTabs = document.querySelectorAll("#pago-tabs .tab-btn");
        const cobroTabs = document.querySelectorAll("#cobro-tabs .tab-btn");

        // Solo colapsar secciones si se indica (cuando cambian monedas, NO cuando cambia solo el monto)
        if (colapsarSecciones) {
            if (pagoContent) {
                pagoContent.classList.remove("expanded");
                pagoTabs.forEach(b => b.classList.remove("selected-method", "hiding", "active"));
            }
            if (cobroContent) {
                cobroContent.classList.remove("expanded");
                cobroTabs.forEach(b => b.classList.remove("selected-method", "hiding", "active"));
            }

            // Ocultar info transferencia solo al cambiar monedas
            const infoTransferencia = document.getElementById("transferencia-info");
            if (infoTransferencia) {
                infoTransferencia.classList.add("d-none");
            }
        }

        // === FILTRO DE PAGO ===
        pagoTabs.forEach((btn) => {
            const nombre = btn.dataset.tipoNombre || btn.textContent.trim();
            const esPYG = from === "PYG";
            const esTauser = nombre === "Tauser";
            const permitidoBase = esPYG || ["Tauser", "Tarjeta Internacional"].includes(nombre);

            btn.style.display = permitidoBase ? "" : "none";
        });

        // === FILTRO DE COBRO ===
        cobroTabs.forEach((btn) => {
            const nombre = btn.dataset.tipoNombre || btn.textContent.trim();
            const esPYG = to === "PYG";
            const esTauser = nombre === "Tauser";

            if (!esPYG) {
                // Solo Tauser cuando to ‚â† PYG
                btn.style.display = esTauser ? "" : "none";
            } else {
                btn.style.display = ""
            }
        });

        // Si el bot√≥n activo qued√≥ oculto ‚Üí activar el primero visible
        [pagoTabs, cobroTabs].forEach((tabList, index) => {
            const activo = Array.from(tabList).find((b) => b.classList.contains("active"));
            if (activo && activo.style.display === "none") {
                const tipo = index === 0 ? "pago" : "cobro"; // para recargar solo el que cambi√≥

                activo.classList.remove("active");
                const visible = Array.from(tabList).find((b) => b.style.display !== "none");
                if (visible) visible.classList.add("active");

                // ‚úÖ Recargar solo los m√©todos correspondientes
                recargarMetodos(tipo);
            }
        });
    }

    function configurarTabsFiltro() {
        const pagoTabs = document.getElementById("pago-tabs");
        const cobroTabs = document.getElementById("cobro-tabs");
        const pagoContent = document.getElementById("pago-content");
        const cobroContent = document.getElementById("cobro-content");
        const selectPago = document.getElementById("simu-metodo-pago");
        const selectCobro = document.getElementById("simu-metodo-cobro");
        const infoTransferencia = document.getElementById("transferencia-info");
        const btnAtrasPago = document.getElementById("pago-btn-atras");
        const btnAtrasCobro = document.getElementById("cobro-btn-atras");

        // Funci√≥n para expandir la secci√≥n de m√©todo de pago - CAMBIOS INSTANT√ÅNEOS (sin animaci√≥n)
        // VERSI√ìN ACTUALIZADA: 2025-12-10 - Oculta select para transferencias en pago y cobro
        const expandirMetodo = async (contentEl, tabsEl, btn, tipo, selectEl) => {
            const todosLosBotones = tabsEl.querySelectorAll(".metodo-btn");
            
            // Ocultar todos los botones excepto el seleccionado (instant√°neo)
            todosLosBotones.forEach(b => {
                if (b !== btn) {
                    b.classList.add("hiding");
                }
            });
            
            // Marcar bot√≥n seleccionado (instant√°neo)
            btn.classList.add("active", "selected-method");
            
            // Expandir contenedor (instant√°neo)
            contentEl.classList.add("expanded");
            
            // Obtener nombre del bot√≥n para verificar si es transferencia
            const nombre = (btn.dataset.tipoNombre || btn.textContent.trim()).toLowerCase();
            const esTransferencia = nombre.includes("cuenta bancaria") || nombre.includes("transferencia");
            
            console.log("DEBUG expandirMetodo:", { tipo, nombre, esTransferencia });
            
            // Controlar visibilidad del select seg√∫n el tipo
            // Solo ocultar select para PAGO con transferencia (el cliente paga al negocio)
            // Para COBRO siempre mostrar select (el cliente elige d√≥nde recibir)
            if (esTransferencia && tipo === "pago") {
                // Ocultar el select solo para PAGO con transferencia
                selectEl.parentElement.classList.add("select-hidden");
                console.log("DEBUG: Ocultando select para transferencia en PAGO");
                
                // Mostrar info de transferencia (datos de cuenta del negocio)
                if (infoTransferencia) {
                    infoTransferencia.classList.remove("d-none");
                }
            } else {
                // Mostrar select para otros m√©todos y para COBRO
                selectEl.parentElement.classList.remove("select-hidden");
                
                // Ocultar info transferencia SOLO si estamos en pago y NO es transferencia
                // (no ocultar cuando el usuario selecciona cobro, para mantener visible los datos de pago)
                if (tipo === "pago" && infoTransferencia) {
                    infoTransferencia.classList.add("d-none");
                }
            }

            // Cargar m√©todos y calcular
            await recargarMetodos(tipo);
            compute();
        };

        // Funci√≥n para colapsar la secci√≥n - CAMBIOS INSTANT√ÅNEOS (sin animaci√≥n)
        // tipo: "pago" o "cobro" - solo oculta transferencia-info si colapsamos PAGO
        const colapsarMetodo = (contentEl, tabsEl, tipo) => {
            const todosLosBotones = tabsEl.querySelectorAll(".metodo-btn");
            const selectWrapper = contentEl.querySelector(".metodo-select-wrapper");
            
            // Remover clase 'expanded' (instant√°neo)
            contentEl.classList.remove("expanded");
            
            // Limpiar clase de ocultamiento del select
            if (selectWrapper) {
                selectWrapper.classList.remove("select-hidden");
            }
            
            // Ocultar info transferencia SOLO si colapsamos la secci√≥n de PAGO
            if (tipo === "pago" && infoTransferencia) {
                infoTransferencia.classList.add("d-none");
            }
            
            // Restaurar todos los botones (instant√°neo)
            todosLosBotones.forEach(b => {
                b.classList.remove("hiding", "selected-method", "active");
                b.removeAttribute('style');
            });
        };

        // Event listeners para botones de pago
        pagoTabs.querySelectorAll(".metodo-btn").forEach(btn =>
            btn.addEventListener("click", () => {
                if (!pagoContent.classList.contains("expanded")) {
                    expandirMetodo(pagoContent, pagoTabs, btn, "pago", selectPago);
                }
            })
        );

        // Event listeners para botones de cobro
        cobroTabs.querySelectorAll(".metodo-btn").forEach(btn =>
            btn.addEventListener("click", () => {
                if (!cobroContent.classList.contains("expanded")) {
                    expandirMetodo(cobroContent, cobroTabs, btn, "cobro", selectCobro);
                }
            })
        );

        // Event listener para bot√≥n "Atr√°s" de pago
        if (btnAtrasPago) {
            btnAtrasPago.addEventListener("click", () => {
                colapsarMetodo(pagoContent, pagoTabs, "pago");
            });
        }

        // Event listener para bot√≥n "Atr√°s" de cobro
        if (btnAtrasCobro) {
            btnAtrasCobro.addEventListener("click", () => {
                colapsarMetodo(cobroContent, cobroTabs, "cobro");
            });
        }
    }


////////////////////////////////////////////////////////////////////////////////////////////////////////
//Validaciones para envi√≥ de datos correctos al backend a modo de guardar la transacci√≥n
///////////////////////////////////////////////////////////////////////////////////////////////////////

    const hiddenInputs = {
        tipo: document.getElementById("input-tipo"),
        moneda_origen: document.getElementById("input-moneda-origen"),
        moneda_destino: document.getElementById("input-moneda-destino"),
        tasa_cambio: document.getElementById("input-tasa-cambio"),
        monto_origen: document.getElementById("input-monto-origen"),
        monto_destino: document.getElementById("input-monto-destino"),
        medio_pago_contenttype: document.getElementById("input-medio-pago-contenttype"),
        medio_cobro_contenttype: document.getElementById("input-medio-cobro-contenttype"),
        medio_pago_tipo: document.getElementById("input-medio-pago-tipo"),
        medio_cobro_tipo: document.getElementById("input-medio-cobro-tipo")
    };

    document.querySelector("form").addEventListener("submit", function (e) {
        const montoOrigen = parseFloat(
            (amount.value || "0").replace(/\./g, "").replace(",", ".")
        );

        if (isNaN(montoOrigen) || montoOrigen <= 0) {
            e.preventDefault();  // Cancela el submit
            alert("Debes ingresar un monto v√°lido antes de confirmar la operaci√≥n");
            amount.focus();
            return;
        }

        // --- Monto destino ---
        let rawDestino = out.value || "0";

        // Quita todo lo que no sea d√≠gito, coma o punto
        rawDestino = rawDestino.replace(/[^\d.,-]/g, "");

        // Si hay coma, asumimos formato europeo (coma = decimal)
        if (rawDestino.includes(",")) {
            rawDestino = rawDestino.replace(/\./g, "").replace(",", ".");
        } else {
            rawDestino = rawDestino.replace(/\./g, "");
        }

        const montoDestino = parseFloat(rawDestino) || 0;

        const a = from.value, b = to.value;

        hiddenInputs.tipo.value = (a === "PYG" && b !== "PYG") ? "VENTA" : "COMPRA";
        hiddenInputs.moneda_origen.value = a;
        hiddenInputs.moneda_destino.value = b;
        hiddenInputs.monto_origen.value = montoOrigen;
        hiddenInputs.monto_destino.value = montoDestino;

        if (a === "PYG" && b !== "PYG") {
            hiddenInputs.tasa_cambio.value = META[b].venta;
        } else if (a !== "PYG" && b === "PYG") {
            hiddenInputs.tasa_cambio.value = META[a].compra;
        }

        if (metodoPago.options.length > 0) {
            hiddenInputs.medio_pago_contenttype.value = metodoPago.selectedOptions[0].dataset.contentTypeId;
        }
        if (metodoCobro.options.length > 0) {
            hiddenInputs.medio_cobro_contenttype.value = metodoCobro.selectedOptions[0].dataset.contentTypeId;
        }

        const btnPagoActivo = document.querySelector("#pago-tabs .tab-btn.active");
        const btnCobroActivo = document.querySelector("#cobro-tabs .tab-btn.active");

        if (btnPagoActivo) {
            hiddenInputs.medio_pago_tipo.value = btnPagoActivo.dataset.tipoGeneral;
        }
        if (btnCobroActivo) {
            hiddenInputs.medio_cobro_tipo.value = btnCobroActivo.dataset.tipoGeneral;
        }

        // --- Validar selecci√≥n ---
        if (!btnPagoActivo || !btnCobroActivo) {
            e.preventDefault();
            alert("Debes seleccionar un m√©todo de pago y cobro antes de continuar");
            return;
        }
    });


////////////////////////////////////////////////////////////////////////////////////////////////////////
//Validar denominaciones para tauser
///////////////////////////////////////////////////////////////////////////////////////////////////////

    function tauserPuedeEntregar(tauserId, currencyCode, monto) {
        const stockInfo = TAUSER_STOCK[tauserId];
        if (!stockInfo || !stockInfo[currencyCode]) return false;

        const denoms = stockInfo[currencyCode]
            .map(d => ({ value: parseFloat(d.value), qty: d.quantity }))
            .sort((a, b) => b.value - a.value);

        let restante = monto;
        for (const d of denoms) {
            if (d.value <= 0) continue;
            let maxUnits = Math.floor(restante / d.value);
            let usar = Math.min(maxUnits, d.qty);
            restante -= usar * d.value;
            if (restante <= 0) return true;
        }

        return false;
    }

    function tauserPuedeRecibir(tauserId, currencyCode, monto) {
        const stockInfo = TAUSER_STOCK[tauserId];
        if (!stockInfo || !stockInfo[currencyCode]) return false;

        // ‚úÖ Usa las mismas denominaciones que √©l maneja (como entregar)
        const denoms = stockInfo[currencyCode]
            .map(d => ({ value: parseFloat(d.value), qty: Infinity })) // recibe sin l√≠mite
            .sort((a, b) => b.value - a.value);

        let restante = monto;
        for (const d of denoms) {
            if (d.value <= 0) continue;
            let usar = Math.floor(restante / d.value);
            restante -= usar * d.value;
            if (restante <= 0) return true;
        }

        return false;
    }

    function tauserMontoMinimoEntregar(tauserId, currencyCode, monto) {
        const stockInfo = TAUSER_STOCK[tauserId];
        if (!stockInfo || !stockInfo[currencyCode]) return null;

        const denoms = stockInfo[currencyCode]
            .map(d => ({ value: parseFloat(d.value), qty: d.quantity }))
            .sort((a, b) => b.value - a.value);

        // primero probamos si puede cubrir exacto
        if (tauserPuedeEntregar(tauserId, currencyCode, monto)) {
            return monto;
        }

        // si no puede exacto, vamos buscando hacia arriba
        let extra = 0;
        while (extra <= monto * 0.5) { // l√≠mite pr√°ctico: no crecer m√°s del 50% (evita loops enormes)
            const intento = monto + extra;
            let restante = intento;

            for (const d of denoms) {
                if (d.value <= 0) continue;
                let usar = Math.min(Math.floor(restante / d.value), d.qty);
                restante -= usar * d.value;
                if (restante <= 0) return intento;
            }

            extra += 1;
        }

        return null; // no puede entregar ni cercano
    }


    function tauserMontoMinimoRecibir(tauserId, currencyCode, monto) {
        const stockInfo = TAUSER_STOCK[tauserId];
        if (!stockInfo || !stockInfo[currencyCode]) return null;

        // ‚úÖ Mismas denominaciones que puede recibir
        const denoms = stockInfo[currencyCode]
            .map(d => ({ value: parseFloat(d.value), qty: Infinity })) 
            .sort((a, b) => b.value - a.value);

        // Si puede exacto
        if (tauserPuedeRecibir(tauserId, currencyCode, monto)) {
            return monto;
        }

        let extra = 0;
        while (extra <= monto * 0.5) {
            const intento = monto + extra;
            let restante = intento;

            for (const d of denoms) {
                if (d.value <= 0) continue;
                let usar = Math.floor(restante / d.value);
                restante -= usar * d.value;
                if (restante <= 0) return intento;
            }
            extra++;
        }

        return null;
    }

    function mostrarSugerenciaTauser(mensaje, targetId) {
        const el = document.getElementById(targetId);

        if (!el) return;

        el.textContent = mensaje;
        el.style.display = mensaje ? "block" : "none";
    }

    function evaluarSugerenciaTauser(selectEl, es_pago) {
        const targetId = es_pago ? "tauser-suggestion-amount" : "tauser-suggestion-out";
        console.log(targetId)

        mostrarSugerenciaTauser("", targetId);

        const monto = es_pago 
            ? parseFloat((amount.value || "0").replace(/\./g,"").replace(",", ".")) || 0 
            : parseFloat((out.value || "0").replace(/\./g,"").replace(",", ".")) || 0;

        const moneda = es_pago ? from.value : to.value;
        const opt = selectEl.selectedOptions[0];
        if (!opt || opt.dataset.contentTypeId != TAUSER_CT_ID || !monto) return;

        const tauserId = parseInt(opt.value);

        // ‚úÖ Caso 1: Cliente paga ‚Üí Tauser recibe
        if (es_pago) {
            if (tauserPuedeRecibir(tauserId, moneda, monto)) return;

            const minimo = tauserMontoMinimoRecibir(tauserId, moneda, monto);

            mostrarSugerenciaTauser(
                minimo
                    ? `Monto sugerido que puede aceptar este Tauser es ${nf(minimo)}`
                    : `Este monto no se puede formar con billetes reales.`,
                targetId
            );
            return;
        }

        // ‚úÖ Caso 2: cliente recibe ‚Üí tauser entrega
        if (tauserPuedeEntregar(tauserId, moneda, monto)) return;

        const minimo = tauserMontoMinimoEntregar(tauserId, moneda, monto);

        mostrarSugerenciaTauser(
            minimo
                ? `El Tauser puede darte ${nf(minimo)}, el m√°s cercano disponible`
                : `Este Tauser no puede entregar este monto con su stock.`,
            targetId
        );
    }

    function aplicarFiltroTauserEnSelect(selectEl, es_pago) {
        const moneda = es_pago ? from.value : to.value;

        for (const opt of [...selectEl.options]) {
            if (!opt.value) continue;
            const id = parseInt(opt.value);

            // ‚úÖ Detectar si es Tauser
            const isTauser = opt.dataset.contentTypeId == TAUSER_CT_ID;
            if (!isTauser) continue;

            const stockInfo = TAUSER_STOCK[id];
            const denoms = stockInfo && stockInfo[moneda];

            // ‚ùå No maneja esa moneda ‚Üí ocultar
            if (!denoms) {
                opt.hidden = true;
                continue;
            }

            // ‚úÖ Calcular total de stock disponible en esa moneda
            const totalStock = denoms.reduce((sum, d) => sum + d.value * d.quantity, 0);

            // ‚úÖ Obtener monto actual
            const monto = es_pago 
                ? parseFloat((amount.value||"0").replace(/\./g,"").replace(",", ".")) || 0
                : parseFloat((out.value||"0").replace(/\./g,"").replace(",", ".")) || 0;

            // ‚ö†Ô∏è Si monto es 0 ‚Üí solo validamos moneda, no ocultamos
            if (!monto) {
                opt.hidden = false;
                continue;
            }

            // ‚ùå Ocultar si stock total < monto
            opt.hidden = totalStock < monto;
        }

        // ‚úÖ Si el seleccionado qued√≥ oculto ‚Üí elegir otro visible
        if (selectEl.selectedOptions.length && selectEl.selectedOptions[0].hidden) {
            const visible = [...selectEl.options].find(o => !o.hidden && o.value);
            selectEl.value = visible ? visible.value : "";
        }
    }


    function evaluarAmbosTausers() {
        const optP = metodoPago?.selectedOptions?.[0];
        const optC = metodoCobro?.selectedOptions?.[0];

        if (!optP || !optC) return;
        if (optP.dataset.contentTypeId != TAUSER_CT_ID) return;
        if (optC.dataset.contentTypeId != TAUSER_CT_ID) return;

        const tauserIdP = parseInt(optP.value);
        const tauserIdC = parseInt(optC.value);

        const montoP = parseFloat((amount.value||"0").replace(/\./g,"").replace(",", ".")) || 0;
        const montoC = parseFloat((out.value||"0").replace(/\./g,"").replace(",", ".")) || 0;

        const monedaP = from.value; 
        const monedaC = to.value;

        const puedeRecibir = tauserPuedeRecibir(tauserIdP, monedaP, montoP);
        const puedeEntregar = tauserPuedeEntregar(tauserIdC, monedaC, montoC);

        // ‚úÖ Ambos perfectos ‚Üí limpiar mensajes
        if (puedeRecibir && puedeEntregar) {
            mostrarSugerenciaTauser("", "tauser-suggestion-amount");
            mostrarSugerenciaTauser("", "tauser-suggestion-out");
            return;
        }

        // ‚úÖ Buscar el monto workable para ambos
        const minimoAmbos = tauserMontoMinimoAmbos(
            tauserIdP, tauserIdC,
            monedaP, monedaC,
            montoP
        );

        if (minimoAmbos) {
            // Solo sugerimos editar amount, NO tocamos out
            mostrarSugerenciaTauser(
                `Monto compatible entre Tausers: ${nf(minimoAmbos, monedaP)}`,
                "tauser-suggestion-amount"
            );
            mostrarSugerenciaTauser("", "tauser-suggestion-out");
        } else {
            mostrarSugerenciaTauser(
                `Ninguno de los Tausers puede operar este monto. Ajust√° el valor.`,
                "tauser-suggestion-amount"
            );
            mostrarSugerenciaTauser("", "tauser-suggestion-out");
        }
    }


    // === 1) Conversi√≥n NUM√âRICA consistente con tu compute() (PYG base) ===
    function convertirMonto(fromCode, toCode, monto) {
        if (isNaN(monto) || monto <= 0) return 0;
        if (fromCode === "PYG" && toCode !== "PYG") {
            // PYG -> X  (usa VENTA de la moneda destino)
            return monto / (META[toCode]?.venta ?? 1);
        } else if (fromCode !== "PYG" && toCode === "PYG") {
            // X -> PYG  (usa COMPRA de la moneda origen)
            return monto * (META[fromCode]?.compra ?? 1);
        } else {
            // Caso inv√°lido en tu UI (no deber√≠a ocurrir por enforceDifferent)
            return 0;
        }
    }

    // === 2) Paso m√≠nimo (granularidad) para aumentar "amount" en la b√∫squeda ===
    // Usa denominaciones del Tauser que RECIBE (pago) para el "from".
    // Si no hay datos, cae a 1; si es PYG y no hay datos, cae a 50.000.
    function pasoMinimoPara(tauserId, currencyCode) {
        const stockInfo = TAUSER_STOCK[tauserId];
        const denoms = stockInfo && stockInfo[currencyCode];
        if (!denoms || !denoms.length) {
            // Defaults razonables
            if (currencyCode === "PYG") return 50000;
            return 1;
        }
        // Elegimos el menor billete como paso (puede reemplazarse por gcd si quieres)
        let min = Infinity;
        for (const d of denoms) {
            const v = Math.floor(parseFloat(d.value));
            if (v > 0 && v < min) min = v;
        }
        if (!isFinite(min)) {
            if (currencyCode === "PYG") return 50000;
            return 1;
        }
        return min;
    }

    function tauserMontoMinimoAmbos(tauserIdP, tauserIdC, monedaP, monedaC, montoInicial) {
        if (!montoInicial || montoInicial <= 0) return null;

        // Paso seg√∫n denominaciones del tauser que recibe (from)
        const step = pasoMinimoPara(tauserIdP, monedaP);

        // Redondear
        const align = (x, s) => Math.ceil(x / s) * s;
        let intento = align(montoInicial, step);

        // Limite m√°ximo preventivo para que nunca se vuelva infinito
        // Si llegamos a 1.000.000.000.000 PYG (1 bill√≥n) ya paramos
        const LIMITE_ABSURDO = 1_000_000_000_000;

        while (intento <= LIMITE_ABSURDO) {
            const intentoDestino = convertirMonto(monedaP, monedaC, intento);

            const okRecibir  = tauserPuedeRecibir(tauserIdP, monedaP, intento);
            const okEntregar = tauserPuedeEntregar(tauserIdC, monedaC, intentoDestino);

            if (okRecibir && okEntregar) {
                return intento;
            }

            intento += step;
        }

        // Si llegamos ac√°, no existe coincidencia razonable
        return null;
    }


////////////////////////////////////////////////////////////////////////////////////////////////////////
//L√≥gica del Wizard
///////////////////////////////////////////////////////////////////////////////////////////////////////

    function mostrarMensaje(texto, tipo = "success", duracion = 4000) {
        // 1. Buscar o crear phantom
        let phantom = document.getElementById("toast-phantom");
        if (!phantom) {
            phantom = document.createElement("div");
            phantom.id = "toast-phantom";
            document.querySelector("header").insertAdjacentElement("afterend", phantom);
        }

        // 2. Buscar o crear contenedor
        let container = document.getElementById("toast-container");
        if (!container) {
            container = document.createElement("div");
            container.id = "toast-container";
            phantom.insertAdjacentElement("afterend", container);
        }

        // 3. Crear el mensaje
        const msg = document.createElement("div");
        msg.className = `toast-message ${tipo}`;
        msg.textContent = texto;
        container.appendChild(msg);

        // 4. Ajustar phantom al alto exacto del mensaje
        requestAnimationFrame(() => {
            phantom.style.height = msg.getBoundingClientRect().height + "px";
        });

        // 5. ACTIVAR STICKY DIN√ÅMICO
        function updateToastPosition() {
            const phantomTop = phantom.getBoundingClientRect().top;
            if (phantomTop <= 0) {
                msg.classList.add("fixed");
            } else {
                msg.classList.remove("fixed");
            }
        }

        window.addEventListener("scroll", updateToastPosition);
        updateToastPosition();

        // 6. Auto-remover
        setTimeout(() => {
            msg.remove();
            phantom.remove();
            if (!container.children.length) container.remove();
        }, duracion);
    }

    document.addEventListener("DOMContentLoaded", () => {
        const step1 = document.getElementById("step-1");
        const step2 = document.getElementById("step-2");
        const next = document.getElementById("next-step");
        const prev = document.getElementById("prev-step");

        const ind1 = document.getElementById("indicator-step1");
        const ind2 = document.getElementById("indicator-step2");

        next.addEventListener("click", () => {
            const montoOrigen = parseFloat(
                (amount.value || "0").replace(/\./g, "").replace(",", ".")
            );

            const codigoMonedaOrigen = from.value; // Ej: "PYG"
            const codigoMonedaDestino = to.value;  // Ej: "USD"
            // Tomar monto destino
            const montoDestinoText = document.getElementById("simu-result-main").value;
            const montoDestino = parseFloat(
                (montoDestinoText || "0").replace(/\./g, "").replace(",", ".")
            );

            // ‚ö†Ô∏è Solo validar si el usuario tiene PYG como origen
            if (codigoMonedaOrigen === "PYG" && LIMITES_INTERCAMBIO[codigoMonedaDestino]) {

                const limiteDia = LIMITES_INTERCAMBIO[codigoMonedaDestino].dia;
                const limiteMes = LIMITES_INTERCAMBIO[codigoMonedaDestino].mes;

                if (montoDestino > limiteDia) {
                    return mostrarMensaje(
                        `El monto en ${codigoMonedaDestino} (${montoDestino.toLocaleString()}) supera el l√≠mite diario (${limiteDia.toLocaleString()} ${codigoMonedaDestino}).`,
                        "error"
                    );
                }

                if (montoDestino > limiteMes) {
                    return mostrarMensaje(
                        `El monto en ${codigoMonedaDestino} (${montoDestino.toLocaleString()}) supera el l√≠mite mensual (${limiteMes.toLocaleString()} ${codigoMonedaDestino}).`,
                        "error"
                    );
                }
            }
                    
            // üü© Determina tipo de operaci√≥n: Venta si es PYG, Compra en otro caso
            const tipoOperacion = from.value.includes("PYG") ? "Venta" : "Compra";

            // Actualiza los datos de resumen
            document.getElementById("resumen-tipo").textContent = tipoOperacion;

            document.getElementById("resumen-origen").textContent =
                `${montoOrigen || "-"} ${from.value || ""}`;

            document.getElementById("resumen-destino").textContent =
                `${out.value || "-"}`;

            document.getElementById("resumen-cobro").textContent =
                metodoCobro?.selectedOptions[0]?.text || "-";

            // Detecta tipo general de pago activo
            const btnActivo = document.querySelector(".tab-btn.active");
            const tipoGeneral = btnActivo?.textContent?.trim().toLowerCase() || "";

            const esTransferencia = tipoGeneral.includes("transferencia");

            // Si es transferencia, cargar datos de cuenta_negocio
            if (esTransferencia) {
                // üè¶ Buscar dentro del bloque visible de transferencia
                const transferenciaInfo = document.querySelector("#transferencia-info .transferencia-datos");
                if (transferenciaInfo) {
                    // Buscar el texto exacto en los <p>
                    const banco = transferenciaInfo.querySelector("p:nth-child(3)")?.textContent?.replace("Banco:", "").trim() || "";
                    const cuenta = transferenciaInfo.querySelector("p:nth-child(4)")?.textContent?.replace("Cuenta:", "").trim() || "";
                    const alias = transferenciaInfo.querySelector("p:nth-child(5)")?.textContent?.replace("Alias:", "").trim() || "";

                    const resumen = `${banco} (${alias}) - ${cuenta}`;
                    document.getElementById("resumen-pago").textContent = resumen;
                } else {
                    document.getElementById("resumen-pago").textContent = "-";
                }
            } else {
                document.getElementById("resumen-pago").textContent =
                    metodoPago?.selectedOptions[0]?.text || "-";
            }

            // Validaciones para pasar de pesta√±a en el wizard
            if (isNaN(montoOrigen) || montoOrigen <= 0) return mostrarMensaje("Monto inv√°lido.", "error");
            if (isNaN(montoDestino) || montoDestino <= 0) return mostrarMensaje("Monto inv√°lido.", "error");

            // Solo exige metodoPago si NO es transferencia
            if (!esTransferencia && metodoPago.value === "")
                return mostrarMensaje("Selecciona un m√©todo de pago.", "error");

            if (metodoCobro.value === "") return mostrarMensaje("Selecciona un m√©todo de cobro.", "error");

            // ‚úÖ Validaci√≥n Tauser ANTES de cambiar de paso
            if (!validarTauserAntesDeContinuar()) return;

            // Cambia la vista
            step1.classList.add("d-none");
            step2.classList.remove("d-none");
            ind1.classList.remove("active");
            ind2.classList.add("active");
        });

        prev.addEventListener("click", () => {
            // Volver al paso anterior
            step2.classList.add("d-none");
            step1.classList.remove("d-none");
            ind2.classList.remove("active");
            ind1.classList.add("active");
        });
    });

    
    function validarTauserAntesDeContinuar() {
        const optP = metodoPago?.selectedOptions?.[0];
        const optC = metodoCobro?.selectedOptions?.[0];

        const monto = parseFloat((amount.value||"0").replace(/\./g,"").replace(",", ".")) || 0;
        const monedaP = from.value;
        const monedaC = to.value;

        // ‚úÖ Caso 1: solo Tauser en PAGO (cliente entrega a Tauser)
        if (optP && optP.dataset.contentTypeId == TAUSER_CT_ID) {
            const idP = parseInt(optP.value);
            const nombreP = optP.textContent.trim();

            if (!tauserPuedeRecibir(idP, monedaP, monto)) {
                mostrarMensaje(
                    `El Tauser "${nombreP}" no puede manejar el monto ingresado en ${monedaP}. Ajust√° el valor.`,
                    "error"
                );
                return false;
            }
        }

        // ‚úÖ Caso 2: solo Tauser en COBRO (Tauser entrega al cliente)
        if (optC && optC.dataset.contentTypeId == TAUSER_CT_ID) {
            const idC = parseInt(optC.value);
            const nombreC = optC.textContent.trim();

            // Para cobro, usamos el monto que el Tauser debe entregar (out)
            const montoDestino = parseFloat((out.value||"0").replace(/\./g,"").replace(",", ".")) || 0;

            if (!tauserPuedeEntregar(idC, monedaC, montoDestino)) {
                mostrarMensaje(
                    `El Tauser "${nombreC}" no puede manejar el monto ingresado en ${monedaC}. Ajust√° el valor.`,
                    "error"
                );
                return false;
            }
        }

        // ‚úÖ Caso 3: AMBOS Tausers
        if (
            optP && optC &&
            optP.dataset.contentTypeId == TAUSER_CT_ID &&
            optC.dataset.contentTypeId == TAUSER_CT_ID
        ) {
            const idP = parseInt(optP.value);
            const idC = parseInt(optC.value);
            const nombreP = optP.textContent.trim();
            const nombreC = optC.textContent.trim();

            const montoDestino = parseFloat((out.value||"0").replace(/\./g,"").replace(",", ".")) || 0;

            const puedeRecibir = tauserPuedeRecibir(idP, monedaP, monto);
            const puedeEntregar = tauserPuedeEntregar(idC, monedaC, montoDestino);

            if (!puedeRecibir) {
                mostrarMensaje(
                    `El Tauser "${nombreP}" no puede manejar el monto ingresado en ${monedaP}. Ajust√° el valor.`,
                    "error"
                );
                return false;
            }

            if (!puedeEntregar) {
                mostrarMensaje(
                    `El Tauser "${nombreC}" no puede manejar el monto ingresado en ${monedaC}. Ajust√° el valor.`,
                    "error"
                );
                return false;
            }
        }

        return true;
    }


})();

</script>
{% endblock %}